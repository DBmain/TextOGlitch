<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="about" xml:space="preserve">
    <value>Text'O'Glitch Experimental.
Написано на C#. Автор и код: t.me/russkiypoopforever.
Графика: t.me/naturalnonsense.
https://github.com/DBmain/TextOGlitch</value>
  </data>
  <data name="clipboardEmpty" xml:space="preserve">
    <value>Буфер пуст!</value>
  </data>
  <data name="convertedToBaseTray" xml:space="preserve">
    <value>Текст сконвертирован в Base64!</value>
  </data>
  <data name="copiedToClipboard" xml:space="preserve">
    <value> Скопирован в буфер обмена.</value>
  </data>
  <data name="copyleft" xml:space="preserve">
    <value>Значок ® скопирован в буфер обмена!</value>
  </data>
  <data name="copyright" xml:space="preserve">
    <value>Значок © скопирован в буфер обмена!</value>
  </data>
  <data name="decodedFromBaseTray" xml:space="preserve">
    <value>Текст декодирован!</value>
  </data>
  <data name="decodedFromBaseTray2" xml:space="preserve">
    <value>Получившийся текст: "</value>
  </data>
  <data name="done" xml:space="preserve">
    <value>Готово!</value>
  </data>
  <data name="doneWithDots" xml:space="preserve">
    <value> готово...</value>
  </data>
  <data name="error" xml:space="preserve">
    <value>Ошибка!</value>
  </data>
  <data name="fg_fileSize" xml:space="preserve">
    <value>Размер файла = </value>
  </data>
  <data name="fg_filesReady" xml:space="preserve">
    <value>Файлов готово:</value>
  </data>
  <data name="fg_fileTooBig" xml:space="preserve">
    <value>Файл слишком большой, и его дальнейшая обработка приведёт к ошибке.\nПожалуйста, выберите другой файл.</value>
  </data>
  <data name="fg_fileTooSmall" xml:space="preserve">
    <value>Файл слишком маленький, чтобы его было возможно обработать.</value>
  </data>
  <data name="fg_glitchingRatio" xml:space="preserve">
    <value>Пропорции ломания (1 - полностью, 100 - 1/100 etc):</value>
  </data>
  <data name="fg_limit" xml:space="preserve">
    <value>В прогрмме установлено ограничение - глитч файлов только до 500 мегабайт, иначе ваш комп взорвётся. Проверено.</value>
  </data>
  <data name="fg_mismatchOfSizes" xml:space="preserve">
    <value>Несоответствие пропорций и размера файла!</value>
  </data>
  <data name="fg_numberOfGlitchingBlocks" xml:space="preserve">
    <value>Количество ломаемых блоков:</value>
  </data>
  <data name="fg_pathError" xml:space="preserve">
    <value>Что-то не так с путями к файлам!</value>
  </data>
  <data name="fg_startByteWarning" xml:space="preserve">
    <value>Начальный байт больше/равен размеру файла. Укажите начальную позицию меньше.</value>
  </data>
  <data name="fg_takeLessGlitchingBlocks" xml:space="preserve">
    <value>Выберите меньшее количество ломаемых блоков! Максимальное в данном случае </value>
  </data>
  <data name="fg_takeLessGlitchingBytes" xml:space="preserve">
    <value>Выберите меньшее количество ломаемых байт в блоке!</value>
  </data>
  <data name="fg_waiting" xml:space="preserve">
    <value>Ждите! Мы в процессе...</value>
  </data>
  <data name="glitchExtent" xml:space="preserve">
    <value>Степень глитча:</value>
  </data>
  <data name="glitchExtentWarning" xml:space="preserve">
    <value>Степень глитча не может быть больше длины текста, либо же поле для ввода пустое!</value>
  </data>
  <data name="inTray" xml:space="preserve">
    <value>Теперь я в трее!</value>
  </data>
  <data name="invisible" xml:space="preserve">
    <value>Пустота скопирована в буфер обмена!</value>
  </data>
  <data name="itsNotBase" xml:space="preserve">
    <value>Это не Base64!</value>
  </data>
  <data name="itsNotBase2" xml:space="preserve">
    <value>Не удалось декодировать текст, потому что это не Base64.</value>
  </data>
  <data name="lenface" xml:space="preserve">
    <value>Lenny Face скопирован в буфер обмена!</value>
  </data>
  <data name="mark" xml:space="preserve">
    <value>Значок ✔ скопирован в буфер обмена!</value>
  </data>
  <data name="of" xml:space="preserve">
    <value>из</value>
  </data>
  <data name="shrug" xml:space="preserve">
    <value>¯\_(ツ)_/¯ скопирован в буфер обмена!</value>
  </data>
  <data name="size" xml:space="preserve">
    <value>Размер:</value>
  </data>
  <data name="trademark" xml:space="preserve">
    <value>Значок ™ скопирован в буфер обмена!</value>
  </data>
  <data name="warning" xml:space="preserve">
    <value>Внимание!</value>
  </data>
  <data name="wordSize" xml:space="preserve">
    <value>Размер слова:</value>
  </data>
  <data name="diggits_letters" xml:space="preserve">
    <value>Цифры и буквы</value>
  </data>
  <data name="digits" xml:space="preserve">
    <value>Цифры</value>
  </data>
  <data name="generate" xml:space="preserve">
    <value>Сгенерировать</value>
  </data>
  <data name="glitch" xml:space="preserve">
    <value>Глитч</value>
  </data>
  <data name="keysGenerated" xml:space="preserve">
    <value>Ключей сгенерировано: </value>
  </data>
  <data name="letters" xml:space="preserve">
    <value>Буквы</value>
  </data>
  <data name="lightGlitch" xml:space="preserve">
    <value>Light-глитч</value>
  </data>
  <data name="replace" xml:space="preserve">
    <value>Замена</value>
  </data>
  <data name="reverse" xml:space="preserve">
    <value>Реверс</value>
  </data>
</root>